# A script with documented rules to generate a CVSS v3.1 vector string if a CVSS v4.0 is supplied. Based on https://github.com/nickleali/mycvss/blob/main/cvss_reverse.py, updated logic for Impact metrics to assume worst case 

# set the source and destination files
source_file = "v4_vectors.txt"
destination_file = "v3_vectors.txt"

# defining vulnerable and subsequent system dictionaries for later comparison

vulnSystemImpacts = ["VC:H", "VI:H", "VA:H"]

subsSystemImpacts = ["SC:H", "SI:H", "SA:H"]

# Open the source file for reading and the destination file for writing
with open(source_file, 'r') as source, open(destination_file, 'w') as destination:
  # Loop through each line in the source file
  for line in source:
    # Read the line and remove any trailing newline character
    line = line.rstrip()
    
    '''
    The checks we need to perform to work backwards from a v4.0 vector to get a v3.1 vector:
    Attack Vector -- directly translate to v3.1
    Attack Requirements -- If AC:H or AT:P, then set AC:H.
    User Interaction -- If UI:P or UI:A, then set UI:R
    Privileges Required -- also directly translate
    Scope -- A little tricky. Basically, we need to see if either CIA or vulnerable or subsequent system has non-N metrics. 
    Impact Metrics -- In the event of two sets, pick the worst case output. For example, if VC=H and SC=L, set C=H.
       

    Exploit maturity -- High equates to Attacked, roughly. Setting Functional to Attacked as well.
        PoC maps to v3.1. Unproven is also the same.
    
    '''
       
    # attack vector checks
    if "AV:N" in line:
        v3_string = "CVSS:3.1/AV:N"
    elif "AV:A" in line: 
        v3_string = "CVSS:3.1/AV:A"
    elif "AV:L" in line:
        v3_string = "CVSS:3.1/AV:L"
    elif "AV:P" in line:
        v3_string = "CVSS:3.1/AV:P"
    else:
        v3_string = "CVSS:3.1/AV:N"

    # attack complexity checks
    if "AT:P" in line:
        v3_string = v3_string + "/AC:H"
    elif "AC:H"  in line:
        v3_string = v3_string + "/AC:H"
    else:
        v3_string = v3_string + "/AC:L"

      # privileges required checks
    if "PR:N" in line:
        v3_string = v3_string + "/PR:N"
    elif "PR:L" in line:
        v3_string = v3_string + "/PR:L"
    elif "PR:H" in line:
        v3_string = v3_string + "/PR:H"
    else:
        v3_string = v3_string + "/PR:N"

      # user interaction checks
    if "UI:P" in line:
        v3_string = v3_string + "/UI:R"
    elif "UI:A" in line:
        v3_string = v3_string + "/PR:L"
    else:
        v3_string = v3_string + "/UI:N"

    # confidentliaty impact metric processing
    # need some better logic and loops for checking for scope changes

    scopeCheckList = ["SC:L", "SC:H", "SI:L", "SI:H", "SA:L", "SA:H"]
    # check v4.0 string for subsequent system impacts and if so, set scope change in v3.1 vector string

    if any(x in line for x in scopeCheckList):
        v3_string = v3_string + "/S:C"
    else:
        v3_string = v3_string + "/S:U"

    # --- Impact metrics (per-dimension worst-case, H > L > N) ---
    # Choose C from worst(VC, SC), I from worst(VI, SI), A from worst(VA, SA)
    RANK = {'N': 1, 'L': 2, 'H': 3}

    def _get_level(s: str, metric: str) -> str:
        """Return 'H', 'L', or 'N' for a given v4 metric in the vector line; default to 'N' if missing."""
        if f"/{metric}:H" in s:
            return 'H'
        if f"/{metric}:L" in s:
            return 'L'
        if f"/{metric}:N" in s:
            return 'N'
        return 'N'

    def _worst(a: str, b: str) -> str:
        """Return the worse level using H > L > N."""
        return a if RANK[a] >= RANK[b] else b

    c_final = _worst(_get_level(line, "VC"), _get_level(line, "SC"))
    i_final = _worst(_get_level(line, "VI"), _get_level(line, "SI"))
    a_final = _worst(_get_level(line, "VA"), _get_level(line, "SA"))

    v3_string = v3_string + f"/C:{c_final}/I:{i_final}/A:{a_final}"
    # --- end impact metrics ---
    
    # handling threat

    try:
        if "E:A" in line:
            v3_string = v3_string + "/E:H"
        elif "E:P" in line:
            v3_string = v3_string + "/E:P"
        elif "E:X" in line:
            v3_string = v3_string + "/E:X"
        else:
            v3_string = v3_string + "/E:X"
    except:
        pass

    # output the derived score in v3_string
      
    print(v3_string)

    # combine the final vector string with the calculator URL if we want to supply that

    url = "https://www.first.org/cvss/calculator/3.1#" + v3_string
           
    # Write the vector and score to the destination file
    # destination.write(calc_value + " " + line + "\n")
    destination.write(v3_string + "\n")

    # end of file check loop

# end of program


